// Copyright 2013 Gushcha Anton
/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
// Written in D programing language
module djass.parser;

import pegged.grammar;
import pegged.tester.grammartester;

enum jassGrammar =
`
# Parses JASS language (used to be main scripting language in Warcraft III game)
# Some extentions: delimeters are expanded, now you can break declarations in multiple lines
JassGrammar:
    EOL <- endOfLine+
    lowerCase  <- [a-z]
    upperCase  <- [A-Z]
    digit      <- [0-9]

    Comment <~ "//" (!endOfLine .)* :EOL
    Spacing <- :(' ' / '\t' / '\r' / '\n' / '\r\n' / Comment)*

    Identifier <~ (lowerCase / upperCase / '_') (lowerCase / upperCase / '_' / digit)*

    TypeDef  < :"type" Identifier :"extends" Identifier
    TypeDefs < TypeDef+

    ArgumentList < Expression (',' Expression)*

    EscapeSequence <~ backslash ( quote
                                / doublequote
                                / backslash
                                / [abfnrtv]
                                )
    DQChar <- EscapeSequence
            / !doublequote .
    StringConst <~ doublequote (DQChar)* doublequote
  
    Integer     <~ digit+
    Sign        <- "-" / "+"

    Decimal     <~ [1-9][0-9]*
    Octal       <~ '0'[0-7]*
    Hex         <~ '$'[0-9a-fA-F]+ / "0"[xX][0-9a-fA-F]
    RawCode     <~ "'" . . . . "'"
    IntConst    <- Sign? (Decimal / Hex / Octal / RawCode)
    RealConst   <~ Sign? Integer? "." Integer? (("e" / "E") Sign? Integer)?
    BoolConst   <- "true" / "false"
    NullLiteral <- "null"
    Const       <- RealConst / IntConst / BoolConst / NullLiteral / StringConst 

    Parens     < '(' Expression ')'
    FuncRef    < "function" Identifier
    ArrayRef   < Identifier "[" ArgumentList  "]"
    FuncCall   < Identifier "(" ArgumentList? ")"

    PrimaryExpression < Const
                      / Identifier 
                      / Parens

    PostfixExpression < ArrayRef 
                      / FuncCall
                      / FuncRef
                      / PrimaryExpression

    UnaryOperator   < '+' / '-' / "not"                  
    UnaryExpression < PostfixExpression
                    / UnaryOperator Expression

    MultiplicativeExpression < UnaryExpression (('*'/ '/' / "mod") MultiplicativeExpression)?
    AdditiveExpression       < MultiplicativeExpression ([-+] AdditiveExpression)?
    RelationalExpression     < AdditiveExpression (("<=" / ">=" / "<" / ">") RelationalExpression)?
    EqualityExpression       < RelationalExpression (("==" / "!=") EqualityExpression)?
    LogicalANDExpression     < EqualityExpression ("and" LogicalANDExpression)?
    Expression               < LogicalANDExpression ("or" Expression)?

    Constant <- "constant"
    POD      <- "integer" / "real" / "boolean" / "string"
    Type     <- POD / "handle" / "code" / Identifier

    PODVarDecl < Type Identifier :"=" Expression
    ArrayDecl  < Type :"array" Identifier
    GlobalVar  < Constant? (PODVarDecl / ArrayDecl)
    GlobalVars < :"globals" (GlobalVar)* :"endglobals"


    Param        < Type Identifier
    ParamList    < Param (',' Param)*
    FunctionDecl < Identifier :"takes" ("nothing" / ParamList) 
                   :"returns" (Type / "nothing")
    NativeDecl   < Constant? :"native" FunctionDecl
    Natives      < NativeDecl+

    # Temporaly to debug first part
    UserDefined < Function*
    Function < "constant"? "function" FunctionDecl LocalVarList StatementList "endfunction" 

    LocalVarList < ("local" VarDecl)*
    VarDecl < Type Identifier ("=" Expression)? / Type "array" Identifier
    
    StatementList < (Statement)*
    Statement < Set / Call / IfThenElse / Loop / ExitWhen / Return / Debug
    Set < "set" Identifier "=" Expression / "set" Identifier "[" Expression "]" "=" Expression
    Call < "call" Identifier "(" Args? ")"
    Args < Expression ("," Expression)*
    IfThenElse < "if" Expression "then" StatementList ElseClause? "endif"
    ElseClause < "else" StatementList / "elseif" Expression "then" StatementList ElseClause?
    Loop < "loop" StatementList "endloop"
    ExitWhen < "exitwhen" Expression
    Return < "return" Expression?
    Debug < "debug" (Set / Call / IfThenElse / Loop)

    JassModule < (TypeDefs / GlobalVars / Natives)* UserDefined
`;

mixin(grammar(jassGrammar));
/*mixin(grammar(`
JassGrammar:
    TypeDefs < Term
    Term     < Factor (Add / Sub)*
    Add      < "+" Factor
    Sub      < "-" Factor
    Factor   < Primary (Mul / Div)*
    Mul      < "*" Primary
    Div      < "/" Primary
    Primary  < Parens / Neg / Number / Variable
    Parens   < :"(" Term :")"
    Neg      < "-" Primary
    Number   < ~([0-9]+)
    Variable <- identifier
`));*/

version(unittest)
{
    import std.stdio;
}
unittest
{
    writeln("Testing jass grammar...");
    auto typeTester = new GrammarTester!(JassGrammar, "TypeDefs");

    writeln("Testing type declarations...");
    typeTester.assertSimilar(`
        type widget extends handle
        type destructable extends widget
    `,
    `
    TypeDefs->
    {
        TypeDef->
        {
            Identifier
            Identifier
        }
        TypeDef->
        {
            Identifier
            Identifier
        }            
    }
    `);

    auto expressionTester = new GrammarTester!(JassGrammar, "Expression");

    writeln("Testing 1+2...");
    expressionTester.assertSimilar(`1+2`,
    `
        Expression->LogicalANDExpression->EqualityExpression
        ->RelationalExpression->AdditiveExpression->
        {
            MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Decimal
            
            AdditiveExpression->MultiplicativeExpression
            ->UnaryExpression->PostfixExpression->
            PrimaryExpression->Const->IntConst->Decimal
        }
    `);
    
    writeln("Testing 1+2+3...");
    expressionTester.assertSimilar(`1+2+3`,
    `
        Expression->LogicalANDExpression->EqualityExpression
        ->RelationalExpression->AdditiveExpression->
        {
            MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Decimal
            
            AdditiveExpression->
            {
            	MultiplicativeExpression->UnaryExpression
	            ->PostfixExpression->PrimaryExpression
	            ->Const->IntConst->Decimal

	            AdditiveExpression->MultiplicativeExpression
	            ->UnaryExpression->PostfixExpression->
	            PrimaryExpression->Const->IntConst->Decimal
            }
        }
    `);
    
    writeln("Testing real...");
    expressionTester.assertSimilar(`0.42`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->RealConst
    `);
    expressionTester.assertSimilar(`.42`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->RealConst
    `);
    expressionTester.assertSimilar(`-42.42e-10`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->RealConst
    `);
    expressionTester.assertSimilar(`+42.42e10`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->RealConst
    `);
    writeln("Testing 0...");
    expressionTester.assertSimilar(`0`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Octal
    `);
    writeln("Testing decimal...");
    expressionTester.assertSimilar(`42`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Decimal
    `);
    writeln("Testing hex...");
    expressionTester.assertSimilar(`0x2A`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Hex
    `);
    expressionTester.assertSimilar(`0X2A`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Hex
    `);
    expressionTester.assertSimilar(`$2A`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Hex
    `);
    writeln("Testing octal...");
    expressionTester.assertSimilar(`052`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Octal
    `);
    writeln("Testing raw code...");
    expressionTester.assertSimilar(`'1D42'`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->RawCode
    `);
    writeln("Testing string literal...");
    expressionTester.assertSimilar(`"Hello, \"world!\"!"`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->StringConst
    `);
    writeln("Testing null literal...");
    expressionTester.assertSimilar(`null`,
    `
        Expression->LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->NullLiteral
    `);

    writeln("Testing or...");
    expressionTester.assertSimilar(`true or true or true`,
    `
        Expression->
        {
            LogicalANDExpression->EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->BoolConst

            Expression->
            {
                LogicalANDExpression->EqualityExpression
                ->RelationalExpression->AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->BoolConst

                Expression->LogicalANDExpression->EqualityExpression
                ->RelationalExpression->AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->BoolConst
            }
        }
    `);
    writeln("Testing and...");
    expressionTester.assertSimilar(`true and true and true`,
    `
        Expression->LogicalANDExpression->
        {
            EqualityExpression
            ->RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->BoolConst

            LogicalANDExpression->
            {
                EqualityExpression
                ->RelationalExpression->AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->BoolConst

                LogicalANDExpression->EqualityExpression
                ->RelationalExpression->AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->BoolConst
            }
        }
    `);
    writeln("Testing equality...");
    expressionTester.assertSimilar(`true == true != true`,
    `
        Expression->LogicalANDExpression->EqualityExpression->
        {
            RelationalExpression->AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->BoolConst

            EqualityExpression->
            {
                RelationalExpression->AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->BoolConst

                EqualityExpression
                ->RelationalExpression->AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->BoolConst
            }
        }
    `);
    writeln("Testing relational...");
    expressionTester.assertSimilar(`0 > 10 < true <= false >= 0xFF`,
    `
        Expression->LogicalANDExpression->EqualityExpression->RelationalExpression->
        {
            AdditiveExpression
            ->MultiplicativeExpression->UnaryExpression
            ->PostfixExpression->PrimaryExpression
            ->Const->IntConst->Octal

            RelationalExpression->
            {
                AdditiveExpression
                ->MultiplicativeExpression->UnaryExpression
                ->PostfixExpression->PrimaryExpression
                ->Const->IntConst->Decimal

                RelationalExpression->
                {
                    AdditiveExpression
                    ->MultiplicativeExpression->UnaryExpression
                    ->PostfixExpression->PrimaryExpression
                    ->Const->BoolConst

                    RelationalExpression->
                    {
                        AdditiveExpression
                        ->MultiplicativeExpression->UnaryExpression
                        ->PostfixExpression->PrimaryExpression
                        ->Const->BoolConst

                        RelationalExpression->AdditiveExpression
                        ->MultiplicativeExpression->UnaryExpression
                        ->PostfixExpression->PrimaryExpression
                        ->Const->IntConst->Hex
                    }
                }
            }
        }
    `);

    writeln("Testing global vars...");
    auto globalsTester = new GrammarTester!(JassGrammar, "GlobalVars");
    globalsTester.assertSimilar(`
        globals 
            real varA = 0.42
            constant integer varB = 42
            handle array varC
        endglobals
    `,
    `
        GlobalVars->
        {
            GlobalVar->PODVarDecl->
            {
                Type->POD 
                Identifier
                Expression->LogicalANDExpression->
                    EqualityExpression->
                    RelationalExpression->
                    AdditiveExpression->
                    MultiplicativeExpression->
                    UnaryExpression->
                    PostfixExpression->
                    PrimaryExpression->
                    Const->RealConst
            }
            GlobalVar->
            {
                Constant
                PODVarDecl->
                {
                    Type->POD
                    Identifier
                    Expression->LogicalANDExpression->
                        EqualityExpression->
                        RelationalExpression->
                        AdditiveExpression->
                        MultiplicativeExpression->
                        UnaryExpression->
                        PostfixExpression->
                        PrimaryExpression->
                        Const->IntConst->Decimal
                }
            }
            GlobalVar->ArrayDecl->
            {
                Type
                Identifier
            }
        }
    `);
    
    writeln("Testing functions...");
    auto funcTester = new GrammarTester!(JassGrammar, "Function");
    funcTester.assertSimilar(`
        function GetRandomDirectionDeg takes nothing returns real
        	return GetRandomReal(0, 360)
    	endfunction
    `,
    `
        Function->
        {
        	FunctionDecl->
        	{
        		Identifier
        		Type->POD
        	}
        	StatementList->
        	{
        		Statement->Return->Expression->LogicalANDExpression
        			->EqualityExpression->RelationalExpression->AdditiveExpression
        			->MultiplicativeExpression->UnaryExpression->PostfixExpression
        			->FuncCall->
    			{
    				Identifier
    				ArgumentList ->
    				{
    					Expression->LogicalANDExpression->EqualityExpression
    						->RelationalExpression->AdditiveExpression
    						->MultiplicativeExpression->UnaryExpression
    						->PostfixExpression->PrimaryExpression
    						->Const->IntConst->Octal
						Expression->LogicalANDExpression->EqualityExpression
    						->RelationalExpression->AdditiveExpression
    						->MultiplicativeExpression->UnaryExpression
    						->PostfixExpression->PrimaryExpression
    						->Const->IntConst->Decimal
    				}
    			}
        	}
        }
    `);
}